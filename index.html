<!DOCTYPE html>
<html>
<head>
<title>stanley capstone</title>
<meta charset="utf-8">


<!-- <link rel="stylesheet" type="text/css" href="css/w2ui.min.css"> -->
<!-- <script type="text/javascript" src="js/w2ui.min.js"></script> -->
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">

<!-- <script defer src="https://cdn.jsdelivr.net/gh/lkwq007/stablediffusion-infinity@v0.1.2/js/toolbar.js"></script> -->
<!-- <script defer src="js/toolbar.js"></script> -->

<script defer src="https://cdn.jsdelivr.net/gh/stanleywalker1/capstone-studio-2@main/js/toolbar.js"></script>
<script defer src="https://cdn.jsdelivr.net/gh/stanleywalker1/capstone-studio-2@main/js/fabric.min.js"></script>
<!-- <script type="text/javascript" src="https://github.com/stanleywalker1/capstone-studio-2/blob/main/js/w2ui.min.js"></script> -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/stanleywalker1/capstone-studio-2@main/js/w2ui.min.js"></script>

<!-- <link rel="stylesheet" type="text/css" href="https://github.com/stanleywalker1/capstone-studio-2/blob/main/css/w2ui.min.css"> -->
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/stanleywalker1/capstone-studio-2@main/css/w2ui.min.css">
    <!-- <script defer src="https://cdn.jsdelivr.net/gh/stanleywalker1/capstone-studio-2@main/js/toolbar.js"></script>  -->


<link rel="stylesheet" href="https://pyscript.net/alpha/pyscript.css" />
<script defer src="https://pyscript.net/alpha/pyscript.js"></script>


<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>


<style>
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}


#container {
  position: relative;
  margin:auto;
  display: block;
}
#container > canvas {
  position: absolute;
  top: 0;
  left: 0;
}
.control {
  display: none;
  background-color: aliceblue;
}
#outer_container {
  width: 100%;
  height: 100vh;
  
}

#hamburger-menu {
  position: fixed;
  top: 10px;
  right: 10px;
  width: 50px;
  height: 50px;
  background-color: #f1f1f1;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  z-index: 1000;
  overflow: hidden;
}

#hamburger-menu::before {
  content: "";
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background-image: radial-gradient(circle, #00ff00, #00ffff, #ff00ff, #ff0000, #ffff00, #00ff00);
  background-size: 300% 300%;
  animation: gradient-animation 6s linear infinite;
  z-index: -1;
}

#hamburger-menu i {
  font-size: 24px;
  position: relative;
  z-index: 1;
}

.fa-bars {
  position: relative;
  display: inline-block;
  width: 24px;
  height: 2px;
  background-color: currentColor;
  transition: background-color 0.3s ease;
}

.fa-bars::before,
.fa-bars::after {
  content: "";
  position: absolute;
  left: 0;
  width: 100%;
  height: 2px;
  background-color: currentColor;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.fa-bars::before {
  top: -6px;
}

.fa-bars::after {
  bottom: -6px;
}

.open .fa-bars {
  background-color: transparent;
}

.open .fa-bars::before {
  transform: translateY(6px) rotate(45deg);
}

.open .fa-bars::after {
  transform: translateY(-6px) rotate(-45deg);
}

@keyframes gradient-animation {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
#toolbar {
  display: block;
}



.generate-button {
  background-color: #f1f1f1;
  border: none;
  color: #333;
  padding: 10px 20px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
}




</style>

</head>
<body>
    <div>
    <button type="button" class="control" id="export">Export</button>
    <button type="button" class="control" id="outpaint">Outpaint</button>
    <button type="button" class="control" id="undo">Undo</button>
    <button type="button" class="control" id="commit">Commit</button>
    <button type="button" class="control" id="transfer">Transfer</button>
    <button type="button" class="control" id="upload">Upload</button>
    <button type="button" class="control" id="draw">Draw</button>
    <input type="text" id="mode" value="selection" class="control">
    <input type="text" id="setup" value="0" class="control">
    <input type="text" id="upload_content" value="0" class="control">
    <textarea rows="1" id="selbuffer" name="selbuffer" class="control"></textarea>
    <fieldset class="control">
        <div>
            <input type="radio" id="mode0" name="mode" value="0" checked>
            <label for="mode0">SelBox</label>
        </div>
        <div>
            <input type="radio" id="mode1" name="mode" value="1">
            <label for="mode1">Image</label>
        </div>
        <div>
            <input type="radio" id="mode2" name="mode" value="2">
            <label for="mode2">Brush</label>
        </div>
    </fieldset>
    </div>
    <div id = "outer_container">
    <div id = "container">
        <canvas id = "canvas0"></canvas>
        <canvas id = "canvas1"></canvas>
        <canvas id = "canvas2"></canvas>
        <canvas id = "canvas3"></canvas>
        <canvas id = "canvas4"></canvas>
        <div id="overlay_container" style="pointer-events: none">
        <canvas id = "overlay_canvas" width="1" height="1"></canvas>
        </div>
    </div>
    <input type="file" name="file" id="upload_file" accept="image/*" hidden>
    <input type="file" name="state" id="upload_state" accept=".sdinf" hidden>
    <div style="position: relative;">
    <div id="toolbar" style></div>
    </div>
</div>


<script>



    alert("starting js");

        function toggleToolbar() {
        console.log("Hamburger menu button clicked");
        const toolbar = document.getElementById("toolbar");
        const hamburgerMenu = document.getElementById("hamburger-menu");
        if (toolbar.style.display === "none" || toolbar.style.display === "") {
            toolbar.style.display = "block";
            hamburgerMenu.classList.add("open");
        } else {
            toolbar.style.display = "none";
            hamburgerMenu.classList.remove("open");
        }
        }

        function aws(name, x, y) {
            return `coming from javascript ${name} ${x} ${y}`;
        }

    

  
    const { initializeApp } = firebase;
   
    const { getStorage, ref, listAll, getDownloadURL, getMetadata, uploadBytesResumable } = firebase.storage;


    const firebaseConfig = {
        apiKey: "AIzaSyCxG7s_Wg6RAC4AQ5ZpkCgt0XcnSqcwt-A",
        authDomain: "nyucapstone-7c22c.firebaseapp.com",
        projectId: "nyucapstone-7c22c",
        storageBucket: "nyucapstone-7c22c.appspot.com",
        messagingSenderId: "658619789110",
        appId: "1:658619789110:web:4eb43edacd4bbfcca74d97",
        measurementId: "G-NCNE4TC0GC",
        databaseURL: "https://nyucapstone-7c22c-default-rtdb.firebaseio.com/",
    };



    const fireapp = initializeApp(firebaseConfig);


    function uploadImageToFirebase(base64_str, time_str) {
    return new Promise((resolve, reject) => {
        alert("starting to upload");
        const atob = (str) => {
            return window.atob(str);
        };

        const byteCharacters = atob(base64_str);
        const byteNumbers = new Uint8Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
    
        
        const analytics = firebase.analytics();

        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], {type: "image/png"});
    

        const storage = firebase.storage(fireapp);
        
      
        const storageRef = firebase.storage().ref(`images/${time_str}.png`);
      
        const uploadTask = storageRef.put(blob);

        alert("sucessful upload to firebae");
        // Replace the successful upload handler with this:
        uploadTask.on("state_changed", (snapshot) => {
            // Handle the progress of the upload
        }, (error) => {
            // Handle the error during the upload
            reject(error);
        }, async () => {
            // Handle the successful upload
            const database = firebase.database();
            const latestImageRef = database.ref("latestImage");
            const downloadURL = await storageRef.getDownloadURL();
            await latestImageRef.set({
            fileName: `${time_str}.png`,
            downloadURL: downloadURL
            });
            resolve();
        });
    });
}
    
    
document.getElementById("hamburger-menu").addEventListener("click", toggleToolbar);
  alert("js loaded");
</script>

<py-env>
- numpy
- Pillow
- micropip:
    - boto3
- paths:
    - ./canvas.py
</py-env>


<py-script>
from pyodide import to_js, create_proxy
from PIL import Image
import io
import time
import base64
from collections import deque
import numpy as np
from js import (
    console,
    document,
    parent,
    devicePixelRatio,
    ImageData,
    Uint8ClampedArray,
    CanvasRenderingContext2D as Context2d,
    requestAnimationFrame,
    window,
    encodeURIComponent,
    w2ui,
    update_eraser,
    update_scale,
    adjust_selection,
    update_count,
    enable_result_lst,
    setup_shortcut,
    update_undo_redo,
    alert,
    uploadImageToFirebase,
    firebase,
    aws,
    fetch
)
answer = aws("hello", 1, 2)
console.log(answer)

#addPhoto("demo")

# async def get_latest_image_from_firebase():
    # alert("get_latest_image_from_firebase called")

    # try:
        # database = firebase.database()
        # alert("try called")
        # latestImageRef = database.ref("latestImage")
        # latestImageSnapshot = await latestImageRef.once("value")
        # latestImageInfo = latestImageSnapshot.val()

      
        # download_url = latestImageInfo["downloadURL"]

       
        # with pyodide.open_url(download_url) as f:
           
            # img = Image.open(f)

        # print("Downloaded image:", str(img))
        # return img
    # except Exception as e:
        # print("Error while getting the latest image from Firebase:", str(e))
        # return None

async def fetch_latest_image_url(database_url):
    console.log("fetch_latest_image called")
    # different methods to call
    response = await fetch(f"{database_url}/latestImage.json")
    console.log(f"response status: {response.status}, status text: {response.statusText}")
    
    latest_image_data = await response.json()
    latest_image_data = latest_image_data.to_py()

    image_url = latest_image_data["downloadURL"]
    image_name = latest_image_data["fileName"]
    console.log(f"Latest image URL: {image_url}")
    console.log(f"Latest image name: {image_name}")

    # Fetch the image data as ArrayBuffer
    image_response = await fetch(image_url)
    image_data = await image_response.arrayBuffer()
    
    
    return image_data, image_name


from canvas import InfCanvas


class History:
    def __init__(self,maxlen=10):
        self.idx=-1
        self.undo_lst=deque([],maxlen=maxlen)
        self.redo_lst=deque([],maxlen=maxlen)
        self.state=None

    def undo(self):
        cur=None
        if len(self.undo_lst):
            cur=self.undo_lst.pop()
            self.redo_lst.appendleft(cur)
        return cur
    def redo(self):
        cur=None
        if len(self.redo_lst):
            cur=self.redo_lst.popleft()
            self.undo_lst.append(cur)
        return cur

    def check(self):
        return len(self.undo_lst)>0,len(self.redo_lst)>0

    def append(self,state,update=True):
        self.redo_lst.clear()
        self.undo_lst.append(state)
        if update:
            update_undo_redo(*self.check())

history = History()

base_lst = [None]
async def draw_canvas() -> None:
    alert("draw_canvas called")
    width=1024
    height=700
    canvas=InfCanvas(1024,700)
    update_eraser(canvas.eraser_size,min(canvas.selection_size_h,canvas.selection_size_w))
    document.querySelector("#container").style.height= f"{height}px"
    document.querySelector("#container").style.width = f"{width}px"
    canvas.setup_mouse()
    canvas.clear_background()
    canvas.draw_buffer()
    canvas.draw_selection_box()
    base_lst[0]=canvas

    # latest_image = await get_latest_image_from_firebase()

    # if latest_image is not None:
        # Log the URL of the latest image to the console
        # console.log(f"Latest image URL: {latest_image.url}")
        # Request the parent window to display the latest image on the canvas
        # (commented out to fix the indentation error)
        # window.parent.postMessage({ type: "displayLatestImageOnCanvas", image: latest_image }, "*")
    # else:
        # print("No latest image found in Firebase.")


async def draw_canvas_func(event):
    alert("draw_canvas gradio called")
    try:
        app=parent.document.querySelector("gradio-app")
        if app.shadowRoot:
            app=app.shadowRoot
        width=app.querySelector("#canvas_width input").value
        height=app.querySelector("#canvas_height input").value
        selection_size=app.querySelector("#selection_size input").value
    except:
        width=1024
        height=768
        selection_size=384
    document.querySelector("#container").style.width = f"{width}px"
    document.querySelector("#container").style.height= f"{height}px"

    database_url = "https://nyucapstone-7c22c-default-rtdb.firebaseio.com"
    image_data, latest_image_name = await fetch_latest_image_url(database_url)
    pil_image = Image.open(io.BytesIO(image_data.to_py()))

    np_image = np.array(pil_image)

    canvas=InfCanvas(int(width),int(height),selection_size=int(selection_size),firebase_image_data=np_image)


    canvas.setup_mouse()
    canvas.clear_background()
    canvas.draw_buffer()
    canvas.draw_selection_box()

    # await canvas.load_image(image_data)


    # Update the canvas buffer with the new image data and redraw the buffer
    h, w, c = canvas.buffer.shape
    canvas.sync_to_buffer()
    canvas.buffer_dirty = True

    h_min = min(h, np_image.shape[0])
    w_min = min(w, np_image.shape[1])



    #  mask = np_image[:, :, 3:4].repeat(4, axis=2)
    #  canvas.buffer[mask > 0] = 0
    #  canvas.buffer[0:h, 0:w, :] += np_image

    mask = np_image[:h_min, :w_min, 3:4].repeat(4, axis=2)
    canvas.buffer[:h_min, :w_min][mask > 0] = 0
    canvas.buffer[:h_min, :w_min] += np_image[:h_min, :w_min]
    
    
    
    canvas.draw_buffer()

    base_lst[0]=canvas

    alert("made it to end of draw_canvas gradio")


import js 

async def export_func(event):
    base = base_lst[0]

    arr = base.export()
    base.draw_buffer()
    base.canvas[2].clear()
    base64_str = base.numpy_to_base64(arr)
    time_str = time.strftime("%Y%m%d_%H%M%S")

    # The rest of the original export_func code
    link = document.createElement("a")
    if len(event.data) > 2 and event.data[2]:
        filename = event.data[2]
    else:
        filename = f"outpaint_{time_str}"
    link.download = f"{filename}.png"
    link.href = "data:image/png;base64," + base64_str
    link.click()
    console.log(f"Canvas saved to {filename}.png")

img_candidate_lst=[None,0]

async def outpaint_func(event):
    base=base_lst[0]
    if len(event.data)==2:
        app=parent.document.querySelector("gradio-app")
        if app.shadowRoot:
            app=app.shadowRoot
        base64_str_raw=app.querySelector("#output textarea").value
        base64_str_lst=base64_str_raw.split(",")
        img_candidate_lst[0]=base64_str_lst
        img_candidate_lst[1]=0
    elif event.data[2]=="next":
        img_candidate_lst[1]+=1
    elif event.data[2]=="prev":
        img_candidate_lst[1]-=1
    enable_result_lst()
    if img_candidate_lst[0] is None:
        return
    lst=img_candidate_lst[0]
    idx=img_candidate_lst[1]
    update_count(idx%len(lst)+1,len(lst))
    arr=base.base64_to_numpy(lst[idx%len(lst)])
    base.fill_selection(arr)
    base.draw_selection_box()

async def undo_func(event):
    base=base_lst[0]
    img_candidate_lst[0]=None
    if base.sel_dirty:
        base.sel_buffer = np.zeros((base.selection_size_h, base.selection_size_w, 4), dtype=np.uint8)
        base.sel_dirty = False
    base.canvas[2].clear()

async def commit_func(event):
    base = base_lst[0]
    img_candidate_lst[0] = None
    if base.sel_dirty:
        base.write_selection_to_buffer()
        base.draw_buffer()
    base.canvas[2].clear()
    if len(event.data) > 2:
        history.append(base.save())

    # sending the image to firebase here
    arr = base.export()
    base64_str = base.numpy_to_base64(arr)
    time_str = time.strftime("%Y%m%d_%H%M%S")

    # Call the JavaScript function to upload the image to Firebase storage
    await js.uploadImageToFirebase(base64_str, time_str)
    

async def history_undo_func(event):
    base=base_lst[0]
    if base.buffer_dirty or len(history.redo_lst)>0:
        state=history.undo()
    else:
        history.undo()
        state=history.undo()
    if state is not None:
        base.load(state)
    update_undo_redo(*history.check())
    
async def history_setup_func(event):
    base=base_lst[0]
    history.undo_lst.clear()
    history.redo_lst.clear()
    history.append(base.save(),update=False)

async def history_redo_func(event):
    base=base_lst[0]
    if len(history.undo_lst)>0:
        state=history.redo()
    else:
        history.redo()
        state=history.redo()
    if state is not None:
        base.load(state)
    update_undo_redo(*history.check())


async def transfer_func(event):
    base=base_lst[0]
    base.read_selection_from_buffer()
    sel_buffer=base.sel_buffer
    sel_buffer_str=base.numpy_to_base64(sel_buffer)
    app=parent.document.querySelector("gradio-app")
    if app.shadowRoot:
        app=app.shadowRoot
    app.querySelector("#input textarea").value=sel_buffer_str
    app.querySelector("#proceed").click()

async def upload_func(event):
    base=base_lst[0]
    # base64_str=event.data[1]
    # Retrieve the base64 encoded image string from the #upload_content HTML element
    base64_str=document.querySelector("#upload_content").value
    base64_str=base64_str.split(",")[-1]
    # base64_str=parent.document.querySelector("gradio-app").shadowRoot.querySelector("#upload textarea").value
    arr=base.base64_to_numpy(base64_str)
    h,w,c=base.buffer.shape
    base.sync_to_buffer()
    base.buffer_dirty=True
    mask=arr[:,:,3:4].repeat(4,axis=2)
    base.buffer[mask>0]=0
    # in case mismatch
    base.buffer[0:h,0:w,:]+=arr
    #base.buffer[yo:yo+h,xo:xo+w,0:3]=arr[:,:,0:3]
    #base.buffer[yo:yo+h,xo:xo+w,-1]=arr[:,:,-1]
    base.draw_buffer()
    if len(event.data)>2:
        history.append(base.save())

async def setup_shortcut_func(event):
    setup_shortcut(event.data[1])
  

document.querySelector("#export").addEventListener("click",create_proxy(export_func))
document.querySelector("#undo").addEventListener("click",create_proxy(undo_func))
document.querySelector("#commit").addEventListener("click",create_proxy(commit_func))
document.querySelector("#outpaint").addEventListener("click",create_proxy(outpaint_func))
document.querySelector("#upload").addEventListener("click",create_proxy(upload_func))

document.querySelector("#transfer").addEventListener("click",create_proxy(transfer_func))
document.querySelector("#draw").addEventListener("click",create_proxy(draw_canvas_func))

async def setup_func():
    document.querySelector("#setup").value="1"

async def reset_func(event):
    base=base_lst[0]
    base.reset()
    
async def load_func(event):
    base=base_lst[0]
    base.load(event.data[1])

async def save_func(event):
    base=base_lst[0]
    json_str=base.save()
    time_str = time.strftime("%Y%m%d_%H%M%S")
    link = document.createElement("a")
    if len(event.data)>2 and event.data[2]:
        filename = str(event.data[2]).strip()
    else:
        filename = f"outpaint_{time_str}"
    # link.download = f"sdinf_state_{time_str}.json"
    link.download = f"{filename}.sdinf"
    link.href = "data:text/json;charset=utf-8,"+encodeURIComponent(json_str)
    link.click()

async def prev_result_func(event):
    base=base_lst[0]
    base.reset()

async def next_result_func(event):
    base=base_lst[0]
    base.reset()

async def zoom_in_func(event):
    base=base_lst[0]
    scale=base.scale
    if scale>=0.2:
        scale-=0.1
        if len(event.data)>2:
            base.update_scale(scale,int(event.data[2]),int(event.data[3]))
        else:
            base.update_scale(scale)
        scale=base.scale
        update_scale(f"{base.width}x{base.height} ({round(100/scale)}%)")

async def zoom_out_func(event):
    base=base_lst[0]
    scale=base.scale
    if scale<10:
        scale+=0.1
        console.log(len(event.data))
        if len(event.data)>2:
            base.update_scale(scale,int(event.data[2]),int(event.data[3]))
        else:
            base.update_scale(scale)
        scale=base.scale
        update_scale(f"{base.width}x{base.height} ({round(100/scale)}%)")

async def sync_func(event):
    base=base_lst[0]
    base.sync_to_buffer()
    base.canvas[2].clear()

async def eraser_size_func(event):
    base=base_lst[0]
    eraser_size=min(int(event.data[1]),min(base.selection_size_h,base.selection_size_w))
    eraser_size=max(8,eraser_size)
    base.eraser_size=eraser_size

async def resize_selection_func(event):
    base=base_lst[0]
    cursor=base.cursor
    if len(event.data)>3:
        console.log(event.data)
        base.cursor[0]=int(event.data[1])
        base.cursor[1]=int(event.data[2])
        base.selection_size_w=int(event.data[3])//8*8
        base.selection_size_h=int(event.data[4])//8*8
        base.refine_selection()
        base.draw_selection_box()
    elif len(event.data)>2:
        base.draw_selection_box()
    else:
        base.canvas[-1].clear()
        adjust_selection(cursor[0],cursor[1],base.selection_size_w,base.selection_size_h)

async def eraser_func(event):
    base=base_lst[0]
    if event.data[1]!="eraser":
        base.canvas[-2].clear()
    else:
        x,y=base.mouse_pos
        base.draw_eraser(x,y)

async def resize_func(event):
    base=base_lst[0]
    width=int(event.data[1])
    height=int(event.data[2])
    if width>=256 and height>=256:
        if max(base.selection_size_h,base.selection_size_w)>min(width,height):
            base.selection_size_h=256
            base.selection_size_w=256
        base.resize(width,height)

async def message_func(event):
    if event.data[0]=="click":
        if event.data[1]=="clear":
            await reset_func(event)
        elif event.data[1]=="save":
            await save_func(event)
        elif event.data[1]=="export":
            await export_func(event)
        elif event.data[1]=="accept":
            await commit_func(event)
        elif event.data[1]=="cancel":
            await undo_func(event)
        elif event.data[1]=="zoom_in":
            await zoom_in_func(event)
        elif event.data[1]=="zoom_out":
            await zoom_out_func(event)
        elif event.data[1]=="redo":
            await history_redo_func(event)
        elif event.data[1]=="undo":
            await history_undo_func(event)
        elif event.data[1]=="history":
            await history_setup_func(event)
    elif event.data[0]=="sync":
        await sync_func(event)
    elif event.data[0]=="load":
        await load_func(event)
    elif event.data[0]=="upload":
        await upload_func(event)
    elif event.data[0]=="outpaint":
        await outpaint_func(event)
    elif event.data[0]=="mode":
        if event.data[1]!="selection":
            await sync_func(event)
        await eraser_func(event)
        document.querySelector("#mode").value=event.data[1]
    elif event.data[0]=="transfer":
        await transfer_func(event)
    elif event.data[0]=="setup":
        await draw_canvas_func(event)
    elif event.data[0]=="eraser_size":
        await eraser_size_func(event)
    elif event.data[0]=="resize_selection":
        await resize_selection_func(event)
    elif event.data[0]=="shortcut":
        await setup_shortcut_func(event)
    elif event.data[0]=="resize":
        await resize_func(event)
    
window.addEventListener("message",create_proxy(message_func))

import asyncio

_ = await asyncio.gather(
  setup_func()
)
</py-script>

</body>
</html>
